import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'workout_task.dart';

/// WorkoutCurriculum - Daily workout curriculum
/// Generated by Gemini and stored locally
class WorkoutCurriculum {
  final String id;
  final String title;
  final String description;
  final String thumbnail;
  final List<WorkoutTask> workoutTaskList;
  final DateTime createdAt;

  // Progress status
  int currentTaskIndex;
  int currentSetIndex;

  WorkoutCurriculum({
    required this.id,
    required this.title,
    required this.description,
    required this.thumbnail,
    required this.workoutTaskList,
    required this.createdAt,
    this.currentTaskIndex = 0,
    this.currentSetIndex = 0,
  });

  /// Total estimated time (minutes)
  int get estimatedMinutes {
    int totalSets = 0;
    for (final task in workoutTaskList) {
      totalSets += task.adjustedSets;
    }
    // Approx 1 min per set + 30 sec rest
    return (totalSets * 1.5).ceil();
  }

  /// Summary text (e.g., "Air Squat and 2 more")
  String get summaryText {
    if (workoutTaskList.isEmpty) return 'No Exercise';
    if (workoutTaskList.length == 1) return workoutTaskList.first.title;
    return '${workoutTaskList.first.title} and ${workoutTaskList.length - 1} more';
  }

  /// Current exercise
  WorkoutTask? get currentTask {
    if (currentTaskIndex < workoutTaskList.length) {
      return workoutTaskList[currentTaskIndex];
    }
    return null;
  }

  /// Next exercise
  WorkoutTask? get nextTask {
    if (currentTaskIndex + 1 < workoutTaskList.length) {
      return workoutTaskList[currentTaskIndex + 1];
    }
    return null;
  }

  /// Whether it's the last exercise
  bool get isLastTask => currentTaskIndex == workoutTaskList.length - 1;

  /// Whether completed
  bool get isCompleted => currentTaskIndex >= workoutTaskList.length;

  /// Move to next set
  void moveToNextSet() {
    final task = currentTask;
    if (task == null) return;

    currentSetIndex++;
    if (currentSetIndex >= task.adjustedSets) {
      // Move to next exercise
      currentTaskIndex++;
      currentSetIndex = 0;
    }
  }

  /// Reset progress
  void reset() {
    currentTaskIndex = 0;
    currentSetIndex = 0;
  }

  factory WorkoutCurriculum.fromMap(Map<String, dynamic> map) {
    return WorkoutCurriculum(
      id: map['id'] ?? '',
      title: map['title'] ?? '',
      description: map['description'] ?? '',
      thumbnail: map['thumbnail'] ?? '',
      workoutTaskList:
          (map['workoutTaskList'] as List<dynamic>?)
              ?.map((e) => WorkoutTask.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      createdAt: map['createdAt'] != null
          ? DateTime.parse(map['createdAt'])
          : DateTime.now(),
      currentTaskIndex: map['currentTaskIndex'] ?? 0,
      currentSetIndex: map['currentSetIndex'] ?? 0,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'thumbnail': thumbnail,
      'workoutTaskList': workoutTaskList.map((e) => e.toMap()).toList(),
      'createdAt': createdAt.toIso8601String(),
      'currentTaskIndex': currentTaskIndex,
      'currentSetIndex': currentSetIndex,
    };
  }

  String toJson() => json.encode(toMap());

  factory WorkoutCurriculum.fromJson(String source) =>
      WorkoutCurriculum.fromMap(json.decode(source));

  // Save/Load SharedPreferences
  static const _key = 'today_curriculum';

  static Future<void> save(WorkoutCurriculum curriculum) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_key, curriculum.toJson());
  }

  static Future<WorkoutCurriculum?> load() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_key);
    if (jsonString != null) {
      final curriculum = WorkoutCurriculum.fromJson(jsonString);
      // User Request: Once created, maintain content (save tokens)
      // if (_isSameDay(curriculum.createdAt, DateTime.now())) {
      return curriculum;
      // }
    }
    return null;
  }

  static bool _isSameDay(DateTime a, DateTime b) {
    return a.year == b.year && a.month == b.month && a.day == b.day;
  }

  static Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_key);
  }
}
